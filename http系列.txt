HTTP (HyperText Transfer Protocol)，即超文本运输协议，是实现网络通信的一种规范
HTTPS 为了保证这些隐私数据能加密传输，让HTTP运行安全的SSL/TLS协议上，即 HTTPS = HTTP + SSL/TLS

区别：
HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密处理，相对更安全
HTTP 和 HTTPS 使用连接方式不同，默认端口也不一样，HTTP是80，HTTPS是443
HTTPS 由于需要设计加密以及多次握手，性能方面不如 HTTP
HTTPS需要SSL，SSL 证书需要钱，功能越强大的证书费用越高

SSL的实现这些功能主要依赖于三种手段：
  对称加密：采用协商的密钥对数据加密
  非对称加密：实现身份认证和密钥协商
  摘要算法：验证信息的完整性
  数字签名：身份验证

UDP（User Datagram Protocol），用户数据包协议，是一个简单的面向数据报的通信协议，即对应用层交下来的报文，
 不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层     
特点：
  UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务
  传输途中出现丢包，UDP 也不负责重发
  当包的到达顺序出现乱序时，UDP没有纠正的功能。
  并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为

TCP（Transmission Control Protocol），传输控制协议，是一种可靠、面向字节流的通信协议，把上面应用层交下来的数据看成无结构的字节流来发送
特点：
  TCP充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。
  此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。
  根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）

TCP和UDP区别：
  TCP 是面向连接的协议，建立连接3次握手、断开连接四次挥手，UDP是面向无连接，数据传输前后不连接连接，发送端只负责将数据发送到网络，接收端从消息队列读取
  TCP 提供可靠的服务，传输过程采用流量控制、编号与确认、计时器等手段确保数据无差错，不丢失。UDP 则尽可能传递数据，但不保证传递交付给对方
  TCP 面向字节流，将应用层报文看成一串无结构的字节流，分解为多个TCP报文段传输后，在目的站重新装配。UDP协议面向报文，不拆分应用层报文，只保留报文边界，一次发送一个报文，接收方去除报文首部后，原封不动将报文交给上层应用
  TCP 只能点对点全双工通信。UDP 支持一对一、一对多、多对一和多对多的交互通信

OSI七层模型
  应用层：定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务
  表示层：使通信的应用程序能够解释交换数据的含义，向上为应用层提供服务，向下接收来自会话层的服务
  会话层：负责建立、管理和终止表示层实体之间的通信会话
  传输层：为两台主机进程之间的通信提供服务，处理数据包错误、数据包次序，以及其他一些关键传输问题
  网络层：选择合适的网间路由和交换节点，确保数据按时成功传送
  数据链路层：将网络层交下来的 IP数据报组装成帧，在两个相邻节点间的链路上传送帧
  物理层：实现计算机节点之间比特流的透明传送

TCP/IP，传输控制协议/网际协议，是指能够在多个不同网络间实现信息传输的协议  
DNS（Domain Names System），域名系统，是互联网一项服务，是进行域名和与之相对应的 IP 地址进行转换的服务器

CDN就是根据用户位置分配最近的资源
原理分析：
  应用CDN后，DNS 返回的不再是 IP 地址，而是一个CNAME(Canonical Name ) 别名记录，指向CDN的全局负载均衡
  CNAME实际上在域名解析的过程中承担了中间人（或者说代理）的角色，这是CDN实现的关键
CDN 目的是为了改善互联网的服务质量，通俗一点说其实就是提高访问速度


HTTP 1.0 浏览器与服务器只保持短暂的连接，每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求
简单来讲，每次与服务器交互，都需要新开一个连接
HTTP1.1中，默认支持长连接（Connection: keep-alive），即在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟
HTTP2.0添加一些新的特性：
  多路复用、二进制分帧、首部压缩、服务器推送

总结
HTTP1.0：
  浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接
HTTP1.1：
  引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用
  在同一个TCP连接里面，客户端可以同时发送多个请求
  虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着
  新增了一些请求方法
  新增了一些请求头和响应头
HTTP2.0：
  采用二进制格式而非文本格式
  完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行
  使用报头压缩，降低开销
  服务器推送

HTTP状态码：
  200（成功）：请求已成功，请求所希望的响应头或数据体将随此响应返回
  204（无内容）：服务器成功处理请求，但没有返回任何内容
  206：服务器成功处理了部分请求 一般用来做断点续传，或者是视频文件等大文件的加载
  301（永久移动）：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置  
  302（临时移动）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求
  304：协商缓存，告诉客户端有缓存，直接使用缓存中的数据，返回页面的只有头部信息，是没有内容部分

  302是http1.0的协议状态码，在http1.1版本的时候为了细化302状态码⼜出来了两个303和307。 
  303明确表示客户端应当采⽤get⽅法获取资源，他会把POST请求变为GET请求进⾏重定向。 
  307会遵照浏览器标准，不会从post变为get


  400（错误请求）： 服务器不理解请求的语法
  401（未授权）： 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
  403（禁止）： 服务器拒绝请求
  404（未找到）： 服务器找不到请求的网页
  405（方法禁用）： 禁用请求中指定的方法
  406（不接受）： 无法使用请求的内容特性响应请求的网页
  407（需要代理授权）： 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理
  408（请求超时）： 服务器等候请求时发生超时

  500（服务器内部错误）：服务器遇到错误，无法完成请求
  501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码
  502（错误网关）： 上游服务器无效
  503（服务不可用）： 服务器目前无法使用（由于超载或停机维护） 超载
  504（网关超时）： 服务器作为网关或代理，但是没有及时从上游服务器收到请求 ： 服务器停机维护时，主动用503响应请求或 nginx 设置限速，超过限速，会返回503
  505（HTTP 版本不受支持）： 服务器不支持请求中所用的 HTTP 协议版本  网关超时

浏览器有哪些缓存： 先强缓存在协商缓存
强制缓存
  强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。当浏览器向服务器发起请求时，
    服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 
    Expires 和 Cache-Control，其中Cache-Control优先级比Expires高。
  强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：
  不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）。
  存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存。
  存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果
  
  协商缓存
    Last-Modified/If-Modified-Since 二者的值都是 GMT 格式的时间字符串， Last-Modified 标记最后文件修改时间， 下一次请求时，请求头中会带上 
    If-Modified-Since 值就是 Last-Modified 告诉服务器我本地缓存的文件最后修改的时间，在服务器上根据文件的最后修改时间判断资源是否有变化， 
    、如果文件没有变更则返回 304 Not Modified ，请求不会返回资源内容，浏览器直接使用本地缓存。当服务器返回 304 Not Modified 的响应时，
    response header 中不会再添加的 Last-Modified 去试图更新本地缓存的 Last-Modified， 因为既然资源没有变化，那么 Last-Modified 也就不会改变；
    如果资源有变化，就正常返回返回资源内容，新的 Last-Modified 会在 response header 返回，并在下次请求之前更新本地缓存的 Last-Modified，
    下次请求时，If-Modified-Since会启用更新后的 Last-Modified。

    Etag/If-None-Match， 值都是由服务器为每一个资源生成的唯一标识串，只要资源有变化就这个值就会改变。
    服务器根据文件本身算出一个哈希值并通过 ETag字段返回给浏览器，接收到 If-None-Match 字段以后，
    服务器通过比较两者是否一致来判定文件内容是否被改变。与 Last-Modified 不一样的是，当服务器返回 304 Not Modified 的响应时，
    由于在服务器上ETag 重新计算过，response header中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化。


 
  Cache-Control  > expires > Etag > Last-Modified
  last-modified：文件的修改时间，精确到秒
  etag：每个文件有一个，改动文件了就变了，就是个文件hash，每个文件唯一
  请求资源时，把用户本地该资源的 etag 同时带到服务端，服务端和最新资源做对比。
  如果资源没更改，返回304，浏览器读取本地缓存。
  如果资源有更改，返回200，返回最新的资源。

GET 和 POST 的区别：
  GET在浏览器回退时是无害的，而POST会再次提交请求。
  GET产生的URL地址可以被Bookmark，而POST不可以。
  GET请求会被浏览器主动cache，而POST不会，除非手动设置。
  GET请求只能进行url编码，而POST支持多种编码方式。
  GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
  GET请求在URL中传送的参数是有长度限制的，而POST没有。
  对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
  GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
  GET参数通过URL传递，POST放在Request body中

三次握手：
  第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)，此时客户端处于 SYN_SENT 状态
  第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，
    为了确认客户端的 SYN，将客户端的 ISN+1作为ACK的值，此时服务器处于 SYN_RCVD 的状态
  第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，值为服务器的ISN+1。此时客户端处于 ESTABLISHED 状态。
    服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接

四次挥手：
  第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态，
    停止发送数据，等待服务端的确认
  第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，
    表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态
  第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。
    此时服务端处于 LAST_ACK 的状态
  第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的
    序列号值，此时客户端处于 TIME_WAIT状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，
    服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态
四次挥手原因
  服务端在收到客户端断开连接Fin报文后，并不会立即关闭连接，而是先发送一个ACK包先告诉客户端收到关闭连接的请求，
  只有当服务器的所有报文发送完毕之后，才发送FIN报文断开连接，因此需要四次挥手
  
TIME_WAIT状态等待2MSL的原因:  
  1:为了保证A发送的最后一个ACK报文能够到达B(这个ACK报文段有可能丢失，因而使处在LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认。
    B会超时重传这个FIN+ACK报文段，而A就能在2MSL时间内收到这个重传的FIN+ACK报文段)
  2:使下一个新的连接中不会出现这种旧的连接请求的报文段




Cookie、sessionStorage、localStorage 的区别  
  cookie数据大小不能超过4k；sessionStorage和localStorage的存储比cookie大得多，可以达到5M+
  cookie设置的过期时间之前一直有效；localStorage永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除
  cookie的数据会自动的传递到服务器；sessionStorage和localStorage数据保存在本地

说说地址栏输入 URL 敲下回车后发生了什么？
URL解析-DNS域名解析-建立TCP连接-发起HTTP请求-服务器响应请求并返回结果-浏览器渲染

页面渲染：
  解析HTML，构建 DOM 树
  解析 CSS ，生成 CSS 规则树
  合并 DOM 树和 CSS 规则，生成 render 树
  布局 render 树（ Layout / reflow ），负责各元素尺寸、位置的计算
  绘制 render 树（ paint ），绘制页面像素信息
  浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（ composite ），显示在屏幕上  

进程是资源分配的最小单位，线程是CPU调度的最小单位

组件通信：
  window.addEventListener('message', function (e) {
      bc.postMessage(e.data);
  });  
  window.parent.postMessage(e.data, '*');
路由：
  hash模式：监听浏览器地址hash值变化，执行相应的js切换网页；
  history模式：利用history API实现url地址改变，网页内容改变；
区别：
  它们的区别最明显的就是hash会在浏览器地址后面增加#号，而history可以自定义地址。

hash指的是地址中#号以及后面的字符，也称为散列值，改变hash，不会重新加载页面， 监听 window 的 hashchange 事件 
history 方法： History.back()、History.forward()、History.go() pushState() replaceState()
监听变化
window.addEventListener('popstate', function(e) {
  //e.state 相当于 history.state
  console.log('state: ' + JSON.stringify(e.state));
  console.log(history.state);
});

script 标签 
  async 和 defer 虽然都是异步的，不过还有一些差异，使用 async 标志的脚本文件一旦加载完成，会立即执行；
  而使用了 defer 标记的脚本文件，需要在 DOMContentLoaded 事件之前执行, 相当于所有元素加载完毕后执行


强缓存和协商缓存
  强缓存： 不发送请求，直接使用缓存重的内容
  协商缓存： 需要向后台发送请求，通过判断是否协商缓存，如果是返回304，浏览器从缓存中读取内容
  
  浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识
  浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中

  强制缓存的情况主要有三种
    1: 不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）
    2: 存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存(暂不分析)
    3: 存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果
    控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高。  
    Expires是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，
    如果客户端的时间小于Expires的值时，直接使用缓存结果。
    Expires是HTTP/1.0的字段，但是现在浏览器默认使用的是HTTP/1.1，那么在HTTP/1.1中网页缓存还是否由Expires控制？

    到了HTTP/1.1，Expire已经被Cache-Control替代，原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，

    那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，
    那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义，那么Cache-Control又是如何控制的呢？ max-age 属性 控制

  协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，协商缓存生效，返回304
  Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间
  Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)
  控制协商缓存的字段分别有：Last-Modified / If-Modified-Since和Etag / If-None-Match，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。
  If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。
  服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，
  若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件

  If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。
  服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，
  、代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200



http请求头和响应头 有什么
  请求头信息：
    accept:  浏览器告诉服务器所支持的数据类型
    Accept-Charset:浏览器能够显示的字符集
    Accept-Encoding：浏览器能够处理的压缩编码
    Accept-Language：浏览器当前设置的语言
    host: 浏览器告诉服务器我想访问服务器的那台主机
    Referer: 浏览器告诉服务器我是从哪里来的（防盗链）
    User-Agent: 浏览器类型、版本信息
    Date: 浏览器告诉服务器我是从什么时候访问的
    X-Request-With: 请求方式
    Connection：浏览器与服务器之间连接的类型
    Cookie：当前页面设置的任何Cookie


  响应头信息：
    Location： 这个就是告诉服务器你要去找谁
    Server: 告诉浏览器服务器的类型
    Content-Type: 告诉浏览器返回的数据类型
    Refresh： 控制了的定时刷新  
    Date：表示消息发送的时间，时间的描述格式由rfc822定义
    Connection：浏览器与服务器之间连接的类型
    Cache-Control：控制HTTP缓存




